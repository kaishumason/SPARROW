[{"path":"/articles/MERFISH_Using_SPARROW.html","id":"reading-in-data","dir":"Articles","previous_headings":"","what":"Reading in Data","title":"Subsampling MERFISH Data Using SPARROW","text":"First read merfish data using function ‘read merfish’. functions returns list following counts: matrix gene counts. dimension #genes (500) #cells n (766757) regions: vector region ids cell. p(14) regions. CT: Cell type classification cell","code":"data = read_merfish()"},{"path":"/articles/MERFISH_Using_SPARROW.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Subsampling MERFISH Data Using SPARROW","text":"use MERFISH colorectal cancer dataset containing 15 cell types 5 annotated regions. gene gg fit model Yi,g∼Pois(μi,g)Y_{,g} \\sim Pois(\\mu_{,g})log(μi,g)=log(Li)+βrig,CT()\\log(\\mu_{,g}) = \\log(L_i) + \\beta^{g,CT()}_{r_i}CT()CT() cell type cell ii, LiL_i library size cell ii, rir_i region cell ii belongs. βrig,CT()\\beta^{g,CT()}_{r_i} expected expression gene gg cell type CT()CT() region rir_i cell types t=1,...15t = 1,...15 regions r,r′r,r' test H0:βrg,t=βr′g,tH_0: \\beta^{g,t}_{r} = \\beta^{g,t}_{r'} original dataset contains approximately 800,000 cells. first downsample 300,000 cells sake speed. use SPARROW select powerful subsample cells can recover majority significant effects.","code":""},{"path":"/articles/MERFISH_Using_SPARROW.html","id":"step-1-one-hot-encoding-region-and-cell-type-classification","dir":"Articles","previous_headings":"Overview","what":"Step 1: One hot encoding region and cell type classification","title":"Subsampling MERFISH Data Using SPARROW","text":"","code":"data$regions = model.matrix(~ regions - 1,                              data = data.frame(regions = data$regions)) data$CT = model.matrix(~ CT - 1, data = data.frame(CT = data$CT))  #Sample out data to make downstream analysis faster ind = c(1:ncol(data$counts))[1:300000] data$counts = data$counts[,ind] data$regions = data$regions[ind,] data$CT = data$CT[ind,]"},{"path":"/articles/MERFISH_Using_SPARROW.html","id":"step-2-expand-the-covariate-matrix-to-incorporate-deconvolution","dir":"Articles","previous_headings":"Overview","what":"Step 2: Expand the Covariate Matrix to Incorporate Deconvolution","title":"Subsampling MERFISH Data Using SPARROW","text":"model variance covariance matrix equal (ZTAZ)−1(Z^TAZ)^{-1}. matrix ZZ equal Z=[X*λt1,...X*λtT]Z = [X*\\lambda_{t_1},...X*\\lambda_{t_T}] .e. append TT copies XX together, weighted deconvolution vectors cell type. matrix AA diagonal Ai,iA_{,} approximately equal exp(Xiβrit+log(1000))\\exp(X_i\\beta_{r_i}^t + \\log(1000)). XiβritX_i\\beta_{r_i}^t gets larger, signal. intend estimate power later, fix lower bound XiβtX_i\\beta^t order place conservative estimate standard error. now,spatial transcriptomic data compute proportion total UMIs come gene,compute 75th percentile values, convert UMIs per 1000 (e.g. 1000*exp(−5)1000*\\exp(-5)). expand covariate matrix use “expand covariate matrix” function takes 6 arguments X: covariate matrix. dimension n p lambda: deconvolution matrix spot. dimension n T family: family downstream glm process one intends use. lib size: library size spot. Either scalar vector length n min reads per 1000: minimum reads per 1000 want test . relevant data selection later. min freq: many non-zero observations column expanded covariate matrix needs valid. Default 500. output list two entries. Valid matrix dimension pp TT tells us cell type-covariate combinations sample size exceed min frequency. X holds expanded covariate matrix, removing invalid cell type-covariate combinations.","code":"#get gene totals and total counts gene_totals = rowSums(data$counts) total_UMI = sum(data$counts)  #get good cutoff value for  cutoff = quantile(log(gene_totals/total_UMI),0.75) #make expanded covariate matrix  expanded_X = sparrow::expand_covariate_matrix(X = data$regions, lambda = data$CT,                             family = \"poisson\",lib_size = colSums(data$counts),                                         min_reads_per_1000 = 1000*exp(cutoff)) valid_cov = matrix(apply(expanded_X,2,function(x){sum(x>0)}) > 50,ncol(data$regions),ncol(data$CT)) expanded_X = expanded_X[,apply(expanded_X,2,function(x){sum(x>0)}) > 50]"},{"path":"/articles/MERFISH_Using_SPARROW.html","id":"step-3-compute-target-standard-error-of-subsample","dir":"Articles","previous_headings":"Overview","what":"Step 3: Compute Target Standard Error of Subsample","title":"Subsampling MERFISH Data Using SPARROW","text":"goal SPARROW identify subsample data subsampled data original data similar power. done comparing standard errors subsample standard errors original dataset. Key procedure specifying minimum effect size δmin\\delta_{\\min}. minimum effect size one cares identifying. example, case poisson regression, one may care identifying log fold changes less certain amount. case let us choose δmin=0.05\\delta_{\\min} = 0.05. covariate jj, let standard error entire dataset σj\\sigma_j. assumptions one can compute power standard error σj\\sigma_j effect size δ\\delta, P(σj,δ)P(\\sigma_j,\\delta). Define P(σj)P(\\sigma_j) average power interval [δmin,δmax,j][\\delta_{\\min},\\delta_{\\max,j}]. δmax\\delta_{max} defined δmax,j=minδ:P(σj,δ)>0.999\\delta_{\\max,j} = \\min_{\\delta}: P(\\sigma_j,\\delta) > 0.999 δmax,j<δmin\\delta_{\\max,j} < \\delta_{\\min}, P(σj)=0.999P(\\sigma_j) = 0.999. Given P(σj)P(\\sigma_j), can compute σtarget,j=maxσj′:P(σj′)>c×P(σj)\\sigma_{\\text{target},j} = \\max_{\\sigma_j '}:P(\\sigma_j ') > c\\times P(\\sigma_j) cc constant close 1 (e.g. 0.99).σtarget,j\\sigma_{\\text{target},j} represents largest standard error recover least cc power original data covariate jj. compute target standard errors c=0.975c = 0.975. compute σtarget,j\\sigma_{\\text{target},j} us “compute target standard error” function. takes 3 arguments X: expanded covariate matrix. dimension n p min effect: smallest effect size wish detect target power approximation: power wish retain compared standard error entire dataset σj\\sigma_j","code":"target_standard_errors = sparrow::compute_target_standard_error(X = expanded_X,                                 min_effect = 0.05,target_power_approx = 0.99)"},{"path":"/articles/MERFISH_Using_SPARROW.html","id":"step-4-subsampling-via-sparrow-2-minutes","dir":"Articles","previous_headings":"Overview","what":"Step 4: Subsampling via SPARROW (~2 minutes)","title":"Subsampling MERFISH Data Using SPARROW","text":"SPARROW subsampling algorithm attempts minimize trace (ZKTAZK)−1(Z_K^TAZ_K)^{-1}. ZKZ_K submatrix ZZ containing KK rows. done via stochastic greedy selection can identify solutions least 1−1/e1-1/e efficient. natural stopping criterion ∀j:(ZKTAZK)jj−1<σtarget,j\\forall j: \\sqrt{(Z_K^TAZ_K)^{-1}_{jj}} < \\sigma_{\\text{target},j} Note δmax,j<δmin\\delta_{\\max,j} < \\delta_{\\min}, amount data needed achieve target standard error plateaus. characterizes ultra scalability SPARROW. run data selection use “data selection” function. takes 5 arguments X: expanded covariate matrix. dimension p n data size: maximum subsample size want take min SE: vector target standard errors log: Logical log progress data selection period: log TRUE, often want print progress iterations output vector indices order selected. Therefore one initially picks subset size 100,000 wants downsample 50,000 observations, simply take first 50,000 indices output. see select around 90,00 cells, 1/3 original sample.","code":"selected_indices = sparrow::data_selection(X = t(expanded_X),                         max_data_size = 300000,min_standard_error = target_standard_errors,                         log = TRUE,period = 10000)  selected_indices = selected_indices[is.na(selected_indices) == F] print(paste0(\"Cells Chosen: \",length(selected_indices)))"},{"path":[]},{"path":"/articles/MERFISH_Using_SPARROW.html","id":"full-data-5-minutes","dir":"Articles","previous_headings":"Overview > Step 4: Downstream Analysis(Poisson GLM)","what":"Full Data (~ 5 minutes)","title":"Subsampling MERFISH Data Using SPARROW","text":"","code":"#get region on  nregion = ncol(data$regions) nCT = ncol(data$CT) #get number of genes  ngene = nrow(data$counts) #get library size of cells  spot_size = colSums(data$counts) #save results to a list  res = list() #start time t1 = Sys.time() for(i in c(1:ngene)){   if(i %%100 == 0){     print(paste0(\"Iteration \",i,\" out of \",ngene))     print(Sys.time() - t1)   }   #save beta    beta = matrix(NA,nregion ,nCT)   #get dimnames of beta    colnames(beta) = colnames(data$CT)   rownames(beta) = colnames(data$regions)   #standard error matrix    SE = matrix(NA,nregion,nCT)   colnames(SE) = colnames(data$CT)   rownames(SE) = colnames(data$regions)   #get counts   Y = data$counts[i,]      for(j in c(1:nCT)){     #get cells that correspond to that cell type     cells = which(data$CT[,j] == 1)     #get covariate matrix      X = data$regions[cells,]     #subset covariate matrix by valid      ct_ind = which(valid_cov[,j] == 1)     X = X[,ct_ind]     #get response      y = Y[cells]     #get offset      offset_cells = log(spot_size)[cells]     #fit model      model = glm(y~X-1+offset(offset_cells),family = \"poisson\")     #save beta      beta[ct_ind,j] = coef(model)     #save standard errors      SE[ct_ind,j] = sqrt(diag(vcov(model)))   }   #save results    res[[i]] = list(beta = beta,SE = SE) } #start time print(Sys.time() - t1)"},{"path":"/articles/MERFISH_Using_SPARROW.html","id":"subsampled-data-2-minutes","dir":"Articles","previous_headings":"Overview > Step 4: Downstream Analysis(Poisson GLM)","what":"Subsampled Data (~ 2 minutes)","title":"Subsampling MERFISH Data Using SPARROW","text":"","code":"#get region on  nregion = ncol(data$regions) nCT = ncol(data$CT) #get number of genes  ngene = nrow(data$counts) #get library size of cells  spot_size = colSums(data$counts) #save results to a list  res_subsample = list() t1 = Sys.time() for(i in c(1:ngene)){   if(i %%100 == 0){     print(paste0(\"Iteration \",i,\" out of \",ngene))     print(Sys.time() - t1)   }   #save beta    beta = matrix(NA,nregion ,nCT)   #get dimnames of beta    colnames(beta) = colnames(data$CT)   rownames(beta) = colnames(data$regions)   #standard error matrix    SE = matrix(NA,nregion,nCT)   colnames(SE) = colnames(data$CT)   rownames(SE) = colnames(data$regions)   #get counts   Y = data$counts[i,]      for(j in c(1:nCT)){     #get cells that correspond to that cell type     cells = selected_indices[data$CT[selected_indices,j] == 1]     #get covariate matrix      X = data$regions[cells,]     #subset covariate matrix by valid      ct_ind = which(valid_cov[,j] == 1)     X = X[,ct_ind]     #get response      y = Y[cells]     #get offset      offset_cells = log(spot_size)[cells]     #fit model      model = glm(y~X-1+offset(offset_cells),family = \"poisson\")     #save beta      beta[ct_ind,j] = coef(model)     #save standard errors      SE[ct_ind,j] = sqrt(diag(vcov(model)))   }   #save results    res_subsample[[i]] = list(beta = beta,SE = SE) }"},{"path":[]},{"path":"/articles/MERFISH_Using_SPARROW.html","id":"compute-contrast-test-scores","dir":"Articles","previous_headings":"Overview > Recall Plot: Contrast Test","what":"Compute contrast test scores","title":"Subsampling MERFISH Data Using SPARROW","text":"","code":"contrast_test = function(beta,SE,upper = T){     pvals = matrix(NA,length(beta),length(beta))     for(j in c(1:length(beta))){       diff = beta[j] - beta       diff_SE = sqrt(SE[j]^2 + SE^2)       pvals[,j] = 2*(1-pnorm(abs(diff/diff_SE)))     }     if(upper){       pvals[upper.tri(pvals)] <- NA     }     diag(pvals) = NA     return(pvals)   }  #get pvalue list for full data and subsampled data  pvalue_subsample = c() pvalue_full = c() for(j in c(1:ngene)){   full_result = res[[j]]   subsample_result = res_subsample[[j]]   nCT = ncol(full_result$beta)   for(k in c(1:nCT)){     p_sub = contrast_test(full_result$beta[,k],full_result$SE[,k])     p_full = contrast_test(subsample_result$beta[,k],subsample_result$SE[,k])          pvalue_subsample = c(pvalue_subsample,p_sub)     pvalue_full = c(pvalue_full,p_full)   }    }   pvalue_subsample_adj = p.adjust(pvalue_subsample, method = \"BH\") pvalue_full_adj = p.adjust(pvalue_full, method = \"BH\")"},{"path":"/articles/MERFISH_Using_SPARROW.html","id":"compute-and-plot-recall","dir":"Articles","previous_headings":"Overview > Recall Plot: Contrast Test","what":"Compute and Plot Recall","title":"Subsampling MERFISH Data Using SPARROW","text":"now adjust pvalues using BH procedure compute recall, assuming results full data model truth, across variety qvalue cutoffs. x-axis shows qvalue cutoff used original dataset. y-axis shows recall subsetted dataset qvalue cutoff 0.05. see recall nearly perfect matter qvalue cutoff chosen. standard analysis 1/3 data can identify nearly effects found full dataset.","code":"CT_names = colnames(res[[1]]$beta) N = min(1000,sum(pvalue_full_adj[is.na(pvalue_full_adj)==F] <= 0.05))  set.seed(110) Nind = 1000  Nindices = floor(seq(1,N,length.out = Nind))  ordered_pvals = sort(pvalue_full_adj[is.na(pvalue_full_adj)==F]) ordered_pvals = ordered_pvals[ordered_pvals < 0.05]  pval_inds = sort(c(1,sample(c(2:length(ordered_pvals)),N-1,replace = F)))     log_p = log(pvalue_full_adj[is.na(pvalue_full_adj)==F],10) log_p = log_p[is.infinite(log_p) == F] min_log_p = min(log_p)   #get numerator and denominator in recall recall = rep(NA,Nind) NUM = rep(0,Nind) DEN = rep(0,Nind) C = rep(0,Nind) for(k in c(1:Nind)){   #get cutoff value    cutoff = max(min(log_p),ordered_pvals[pval_inds[k]])      standard_sig = (pvalue_full_adj <= cutoff & is.na(pvalue_subsample_adj) == F)   query_sig = (pvalue_subsample_adj <= 0.05)      NUM[k] =  sum(standard_sig * query_sig,na.rm = T)   DEN[k] = sum(standard_sig,na.rm = T)   recall[k] = NUM[k]/DEN[k]   C[k] = log(cutoff,10)     if(is.infinite(C[k])){       C[k] = min(log_p)     } }   # Example data   plot_data <- data.frame(     C = C,                # Replace with your actual 'C' values     recall = recall # Replace with your actual 'recall' values   )      # Create the plot   PLOT = ggplot(plot_data, aes(x = C, y = recall)) +     geom_point() +  # Scatter points     geom_line() +   # Optional: Connect points with lines     scale_y_continuous(       limits = c(0, 1),            # Set y-axis limits       breaks = seq(0, 1, by = 0.1) # Add y-axis ticks     ) +     theme_minimal() +  # Use a clean theme     labs(       x = \"Full Data Log Q-value Cutoff\",          # Label for the x-axis       y = \"Recall\",     # Label for the y-axis       title = paste0(\"Recall of Subsetted Data: \")     ) +     theme(       panel.grid.major = element_line(color = \"grey80\"), # Add a grid       panel.grid.minor = element_blank()                 # Optional: Hide minor grids     )   print(PLOT) #compute type 1 error  standard_null = (pvalue_full_adj > 0.05 & is.na(pvalue_subsample_adj) == F) query_sig = (pvalue_subsample_adj <= 0.05) type_1_error = sum(query_sig * standard_null,na.rm = T)/sum(standard_null,na.rm = T) #print  print(paste0(\"Type 1 error rate: \",round(type_1_error,2)))"},{"path":"/articles/Subsampling_Data_Using_SPARROW.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Subsampling Data Using SPARROW","text":"SPARROW (Submodular Power Adaptive data Reduction Representative dOWnstream analysis) method selects subsample size KK large scale dataset. subsample chosen maximizes power downstream analysis (e.g. regression). done minimizing trace (XTX)−1(X^TX)^{-1} corresponds sum square standard errors standard linear regression. case large scale spatial-omic data contains mixtures cells called spots, covariate matrix Xn×pX_{n \\times p} must expanded dimension n×(p×T)n \\times (p\\times T) TT number cell types sample. technical details can found supplementary.","code":""},{"path":"/articles/Subsampling_Data_Using_SPARROW.html","id":"step-1-simulating-data","dir":"Articles","previous_headings":"","what":"Step 1: Simulating Data","title":"Subsampling Data Using SPARROW","text":"use simulate data function sparrow simulate 100,000 spots 8 cell types. spot contains 2 cell types. simulate data according model Yi∼Pois(∑t=1Tλi,texp(Xiβt+log(1000)))Y_i \\sim Pois(\\sum_{t=1}^{T}\\lambda_{,t}\\exp(X_i\\beta^t + \\log(1000))) YiY_i response (e.g. gene expression) spot ii, XiX_i covariate vector spot ii,tt denotes cell type, λi,t\\lambda_{,t} deconvolution estimate cell type tt spot ii, βt\\beta^t effect vector cell type tt. Note cell type gets different effect vector. Also note columns XX bounded 0 1. Bounding columns interval recommended prevent scaling issues make interpretation easier.","code":"data = sparrow::simulate_data(n = 1e5, nct = 8,effect_range = c(-0.2,0.2),min_effect = 0.05,                               intercept_range = c(-6,-4),                               library_size = 1000, spot_ct = 2,                               p = 8,num_null = 2,prob_ct = NULL)"},{"path":"/articles/Subsampling_Data_Using_SPARROW.html","id":"step-2-expand-the-covariate-matrix-to-incorporate-deconvolution","dir":"Articles","previous_headings":"","what":"Step 2: Expand the Covariate Matrix to Incorporate Deconvolution","title":"Subsampling Data Using SPARROW","text":"model variance covariance matrix equal (ZTAZ)−1(Z^TAZ)^{-1}. matrix ZZ equal Z=[X*λt1,...X*λtT]Z = [X*\\lambda_{t_1},...X*\\lambda_{t_T}] .e. append TT copies XX together, weighted deconvolution vectors cell type. matrix AA diagonal Ai,iA_{,} approximately equal exp(Xiβt+log(1000))\\exp(X_i\\beta^t + \\log(1000)). XiβtX_i\\beta^t gets larger, signal. intend estimate power later, fix lower bound XiβtX_i\\beta^t order place conservative estimate standard error. now, let bound equal −5-5. general, one can spatial transcriptomic data compute proportion total UMIs come gene,compute 75th percentile values, convert UMIs per 1000 (e.g. 1000*exp(−5)1000*\\exp(-5)). expand covariate matrix use “expand covariate matrix” function takes 6 arguments X: covariate matrix. dimension n p lambda: deconvolution matrix spot. dimension n T family: family downstream glm process one intends use. lib size: library size spot. Either scalar vector length n min reads per 1000: minimum reads per 1000 want test . relevant data selection later. min freq: many non-zero observations column expanded covariate matrix needs valid. Default 500. output list two entries. Valid matrix dimension pp TT tells us cell type-covariate combinations sample size exceed min frequency. X holds expanded covariate matrix, removing invalid cell type-covariate combinations.","code":"expanded_X = sparrow::expand_covariate_matrix(X = data$X, lambda = data$lambda,                                             family = \"poisson\",lib_size = 1000,                                             min_reads_per_1000 = 1000*exp(-5))"},{"path":"/articles/Subsampling_Data_Using_SPARROW.html","id":"step-3-compute-target-standard-error-of-subsample","dir":"Articles","previous_headings":"","what":"Step 3: Compute Target Standard Error of Subsample","title":"Subsampling Data Using SPARROW","text":"goal SPARROW identify subsample data subsampled data original data similar power. done comparing standard errors subsample standard errors original dataset. Key procedure specifying minimum effect size δmin\\delta_{\\min}. minimum effect size one cares identifying. example, case poisson regression, one may care identifying log fold changes less certain amount. case let us choose δmin=0.05\\delta_{\\min} = 0.05. covariate jj, let standard error entire dataset σj\\sigma_j. assumptions one can compute power standard error σj\\sigma_j effect size δ\\delta, P(σj,δ)P(\\sigma_j,\\delta). Define P(σj)P(\\sigma_j) average power interval [δmin,δmax,j][\\delta_{\\min},\\delta_{\\max,j}]. δmax\\delta_{max} defined δmax,j=minδ:P(σj,δ)>0.999\\delta_{\\max,j} = \\min_{\\delta}: P(\\sigma_j,\\delta) > 0.999 δmax,j<δmin\\delta_{\\max,j} < \\delta_{\\min}, P(σj)=0.999P(\\sigma_j) = 0.999. Given P(σj)P(\\sigma_j), can compute σtarget,j=maxσj′:P(σj′)>c×P(σj)\\sigma_{\\text{target},j} = \\max_{\\sigma_j '}:P(\\sigma_j ') > c\\times P(\\sigma_j) cc constant close 1 (e.g. 0.99).σtarget,j\\sigma_{\\text{target},j} represents largest standard error recover least cc power original data covariate jj. compute target standard errors c=0.99c = 0.99. compute σtarget,j\\sigma_{\\text{target},j} us “compute target standard error” function. takes 3 arguments X: expanded covariate matrix. dimension n p min effect: smallest effect size wish detect target power approximation: power wish retain compared standard error entire dataset σj\\sigma_j output vector target standard errors.","code":"target_standard_errors = sparrow::compute_target_standard_error(X = expanded_X,                                 min_effect = 0.05,target_power_approx = 0.99)"},{"path":"/articles/Subsampling_Data_Using_SPARROW.html","id":"step-4-subsampling-via-sparrow-1-minute","dir":"Articles","previous_headings":"","what":"Step 4: Subsampling via SPARROW (~1 minute)","title":"Subsampling Data Using SPARROW","text":"SPARROW subsampling algorithm attempts minimize trace (ZKTAZK)−1(Z_K^TAZ_K)^{-1}. ZKZ_K submatrix ZZ containing KK rows. done via stochastic greedy selection can identify solutions least 1−1/e1-1/e efficient. natural stopping criterion ∀j:(ZKTAZK)jj−1<σtarget,j\\forall j: \\sqrt{(Z_K^TAZ_K)^{-1}_{jj}} < \\sigma_{\\text{target},j} Note δmax,j<δmin\\delta_{\\max,j} < \\delta_{\\min}, amount data needed achieve target standard error plateaus. characterizes ultra scalability SPARROW. run data selection use “data selection” function. takes 5 arguments X: expanded covariate matrix. dimension p n data size: maximum subsample size want take min SE: vector target standard errors log: Logical log progress data selection period: log TRUE, often want print progress iterations output vector indices order selected. Therefore one initially picks subset size 100,000 wants downsample 50,000 observations, simply take first 50,000 indices output. Note select approximately 30,000 100,000 total spots.","code":"selected_indices = sparrow::data_selection(X = t(expanded_X),                         max_data_size = 80000,                         min_standard_error = target_standard_errors,                         log = TRUE,period = 5000) selected_indices = selected_indices[is.na(selected_indices) == F] print(paste0(\"#Cells Subsampled: \", length(selected_indices)))"},{"path":"/articles/Subsampling_Data_Using_SPARROW.html","id":"step-4-example-downstream-analysis-5-minuts","dir":"Articles","previous_headings":"","what":"Step 4: Example Downstream Analysis (~5 minuts)","title":"Subsampling Data Using SPARROW","text":"test performance subsampled dataset, run spotGLM original dataset subsampled data. see power datasets near identical.","code":"nsim = 25 full_power = rep(NA,nsim) subset_power = rep(NA,nsim) full_time = rep(NA,nsim) subset_time = rep(NA,nsim) t1 = Sys.time() for(j in c(1:nsim)){   #simulate new response vector   expected_value = spotglm::spot_poisson$predict(X = data$X,beta = data$beta,                                                   lambda = data$lambda,                                                  offset = rep(log(1000),                                                               length(data$y)))   expected_value = expected_value$total   data$y = rpois(1e5,lambda = expected_value)   #run spotglm on original dataset   model_full = spotglm::run_model(y = data$y, X = data$X, lambda = data$lambda,                          offset = rep(log(1000),length(data$y)),                         family = \"spot poisson\",initialization = T,                         batch_size = 500,n_epochs = 100,                         improvement_threshold = 1e-6,max_conv = 20)    #run spotglm on subsetted data   model_subset = spotglm::run_model(y = data$y[selected_indices],                         X = data$X[selected_indices,],                          lambda = data$lambda[selected_indices,],                          offset=rep(log(1000),length(data$y))[selected_indices],                         family = \"spot poisson\",initialization = T,                         batch_size = 500,n_epochs = 100,                         improvement_threshold = 1e-6,max_conv = 20)      #compute power    full_sig = abs(model_full$beta_est/model_full$stand_err_mat)>1.96   subset_sig = abs(model_subset$beta_est/model_subset$stand_err_mat)>1.96   full_power[j] = sum(full_sig * (1-data$null_beta))/sum(1-data$null_beta)   subset_power[j] = sum(subset_sig * (1-data$null_beta))/sum(1-data$null_beta)   #sompute time   full_time[j] = model_full$time   subset_time[j] = model_subset$time } print(Sys.time() - t1) print(paste0(\"Mean Power on Full Data: \", round(mean(full_power),3))) print(paste0(\"Mean Power on Subsetted Data: \", round(mean(subset_power),3)))"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kaishu Mason. Author. Yijia Jiang. Author. Nancy R. Zhang. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mason K, Jiang Y, Zhang N (2025). sparrow: Submodular Power Adaptive data Reduction Representative Downstream analysis. R package version 0.1.0, https://github.com/kaishumason/SPARROW.","code":"@Manual{,   title = {sparrow: Submodular Power Adaptive data Reduction for Representative Downstream analysis},   author = {Kaishu Mason and Yijia Jiang and Nancy R. Zhang},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/kaishumason/SPARROW}, }"},{"path":"/index.html","id":"sparrow","dir":"","previous_headings":"","what":"SPARROW","title":"SPARROW","text":"sparrow may small, fully equipped vital organs… SPARROW method subsampling large scale data obtain lightweight presentation statistical power preserved respect downstream analysis. originally designed large scale spatial transcriptomics data analysis, used conjunction spotGLM package identifying spatial signals. However, can used general purpose data selection tool. name “sparrow” comes Chinese idiom,“sparrow may small, fully equiped vital organs”. letters acronym stand : Submodular Power-Adaptive Reduction Representative Downstream Workflows. See website full tutorial.","code":""},{"path":"/reference/compute_target_standard_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Target Standard Errors for Covariates — compute_target_standard_error","title":"Compute Target Standard Errors for Covariates — compute_target_standard_error","text":"Estimates minimum required standard errors detecting given effect sizes desired power.","code":""},{"path":"/reference/compute_target_standard_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Target Standard Errors for Covariates — compute_target_standard_error","text":"","code":"compute_target_standard_error(   X,   min_effect,   target_power_approx,   alpha,   acc = 0.001 )"},{"path":"/reference/compute_target_standard_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Target Standard Errors for Covariates — compute_target_standard_error","text":"X Design matrix min_effect Minimum effect size(s) detect target_power_approx Approximate desired statistical power (0-1) alpha Type error rate (e.g., 0.05) acc Accuracy numeric search (default: 1e-3)","code":""},{"path":"/reference/compute_target_standard_error.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Target Standard Errors for Covariates — compute_target_standard_error","text":"vector minimum standard errors covariate","code":""},{"path":"/reference/data_selection.html","id":null,"dir":"Reference","previous_headings":"","what":"Select Data with Early Stopping Based on Standard Errors — data_selection","title":"Select Data with Early Stopping Based on Standard Errors — data_selection","text":"Performs greedy data selection early stopping criterion standard errors converge.","code":""},{"path":"/reference/data_selection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select Data with Early Stopping Based on Standard Errors — data_selection","text":"","code":"data_selection(   X,   max_data_size,   min_standard_error = NULL,   log = FALSE,   period = 1000 )"},{"path":"/reference/data_selection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select Data with Early Stopping Based on Standard Errors — data_selection","text":"X Covariate matrix (p x n) max_data_size maximum number data points select min_standard_error Target standard errors convergence log Whether print progress period log = TRUE, print progress every period","code":""},{"path":"/reference/data_selection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select Data with Early Stopping Based on Standard Errors — data_selection","text":"vector selected data point indices","code":""},{"path":"/reference/data_selection_fixed.html","id":null,"dir":"Reference","previous_headings":"","what":"Select Informative Data Points for Modeling — data_selection_fixed","title":"Select Informative Data Points for Modeling — data_selection_fixed","text":"Selects subset data points minimize standard error using greedy optimization.","code":""},{"path":"/reference/data_selection_fixed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select Informative Data Points for Modeling — data_selection_fixed","text":"","code":"data_selection_fixed(X, data_size, log = FALSE, period = 1000)"},{"path":"/reference/data_selection_fixed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select Informative Data Points for Modeling — data_selection_fixed","text":"X Covariate matrix (p x n) data_size Number data points select log Whether print progress every 1000 iterations period log = TRUE, print progress every period","code":""},{"path":"/reference/data_selection_fixed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select Informative Data Points for Modeling — data_selection_fixed","text":"vector selected data point indices","code":""},{"path":"/reference/expand_covariate_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand Covariate Matrix Based on Cell Type Proportions — expand_covariate_matrix","title":"Expand Covariate Matrix Based on Cell Type Proportions — expand_covariate_matrix","text":"Expands design matrix X using cell type proportions lambda, applying scaling sequencing depth removing low-frequency features.","code":""},{"path":"/reference/expand_covariate_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand Covariate Matrix Based on Cell Type Proportions — expand_covariate_matrix","text":"","code":"expand_covariate_matrix(   X,   lambda,   family = \"gaussian\",   keep_coef = matrix(TRUE, ncol(X), ncol(lambda)),   lib_size = rep(1, nrow(X)),   min_reads_per_1000 = 1,   max_noise_sd = 1 )"},{"path":"/reference/expand_covariate_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand Covariate Matrix Based on Cell Type Proportions — expand_covariate_matrix","text":"X Covariate matrix dimension (n times p) lambda Matrix cell type proportions (n x k) family Model family: \"poisson\", \"negative binomial\", \"gaussian\" keep_coef Matrix (p k) indicating coefficients keep case one knows remove priori(default: TRUEs) lib_size Library sizes sample (default: 1 ) min_reads_per_1000 family == \"poisson\" \"negative binomial\" Minimum reads per 1000 robust scaling (default: 1) max_noise_sd family == \"gaussian\" maximum standard deviation error term used robust scaling (default: 1)","code":""},{"path":"/reference/expand_covariate_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand Covariate Matrix Based on Cell Type Proportions — expand_covariate_matrix","text":"scaled expanded covariate matrix","code":""},{"path":"/reference/min_effect_optimizer.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Minimum Detectable Effect Size — min_effect_optimizer","title":"Compute Minimum Detectable Effect Size — min_effect_optimizer","text":"Calculates minimum detectable effect size given standard error desired power.","code":""},{"path":"/reference/min_effect_optimizer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Minimum Detectable Effect Size — min_effect_optimizer","text":"","code":"min_effect_optimizer(SE, pow, alpha = 0.05, acc = 0.001)"},{"path":"/reference/min_effect_optimizer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Minimum Detectable Effect Size — min_effect_optimizer","text":"SE Standard error pow Desired power alpha Type error rate acc Accuracy search","code":""},{"path":"/reference/power_calc.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Statistical Power — power_calc","title":"Compute Statistical Power — power_calc","text":"Calculates power detect effect given standard error significance level.","code":""},{"path":"/reference/power_calc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Statistical Power — power_calc","text":"","code":"power_calc(SE, effect, alpha = 0.05)"},{"path":"/reference/power_calc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Statistical Power — power_calc","text":"SE Standard error effect Effect size alpha Type error rate","code":""},{"path":"/reference/power_integral.html","id":null,"dir":"Reference","previous_headings":"","what":"Average Power Over a Range of Effect Sizes — power_integral","title":"Average Power Over a Range of Effect Sizes — power_integral","text":"Computes average power uniform distribution effect sizes.","code":""},{"path":"/reference/power_integral.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Average Power Over a Range of Effect Sizes — power_integral","text":"","code":"power_integral(SE, effect_min, effect_max, alpha)"},{"path":"/reference/power_integral.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Average Power Over a Range of Effect Sizes — power_integral","text":"SE Standard error effect_min Minimum effect size effect_max Maximum effect size alpha Type error rate","code":""},{"path":"/reference/read_merfish.html","id":null,"dir":"Reference","previous_headings":"","what":"Read MERFISH Example Data from GitHub — read_merfish","title":"Read MERFISH Example Data from GitHub — read_merfish","text":"Downloads loads MERFISH example data public GitHub repository. function retrieves cell type annotations, spatial region labels, gene expression count matrices (10 chunks), returns list.","code":""},{"path":"/reference/read_merfish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read MERFISH Example Data from GitHub — read_merfish","text":"","code":"read_merfish(num_chunks = 10)"},{"path":"/reference/read_merfish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read MERFISH Example Data from GitHub — read_merfish","text":"num_chunks Integer 0 10. Controls many count matrix chunks download load. Defaults 10 (chunks). Use 0 skip loading counts.","code":""},{"path":"/reference/read_merfish.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read MERFISH Example Data from GitHub — read_merfish","text":"named list three elements: counts matrix data frame gene expression counts (combined multiple chunks). regions vector factor region labels cell. CT vector factor cell types cell.","code":""},{"path":"/reference/read_merfish.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read MERFISH Example Data from GitHub — read_merfish","text":"function requires internet connection download data https://github.com/kaishumason/SpotGLM-Example-Data. function assumes repository structure filenames consistent expected format.","code":""},{"path":"/reference/read_merfish.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read MERFISH Example Data from GitHub — read_merfish","text":"","code":"if (FALSE) { # \\dontrun{ data_list <- read_merfish_data(num_chunks = 5) head(data_list$counts) table(data_list$CT) } # }"},{"path":"/reference/read_spatial_atac.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Spatial ATAC-Seq Example Data — read_spatial_atac","title":"Read Spatial ATAC-Seq Example Data — read_spatial_atac","text":"Loads spatial ATAC-seq data GitHub repository, including coordinates, deconvolution, region-level features, motif score matrices.","code":""},{"path":"/reference/read_spatial_atac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Spatial ATAC-Seq Example Data — read_spatial_atac","text":"","code":"read_spatial_atac()"},{"path":"/reference/read_spatial_atac.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Spatial ATAC-Seq Example Data — read_spatial_atac","text":"list containing: coords Spatial coordinates matrix. regions Matrix data frame spatial regions per spot. deconv Cell type deconvolution matrix. motif_scores Matrix motif activity scores per region.","code":""},{"path":"/reference/read_spatial_atac.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Spatial ATAC-Seq Example Data — read_spatial_atac","text":"","code":"if (FALSE) { # \\dontrun{ atac_data <- read_spatial_atac() names(atac_data) } # }"},{"path":"/reference/read_spatial_long_read.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Spatial Long-Read RNA-Seq Data — read_spatial_long_read","title":"Read Spatial Long-Read RNA-Seq Data — read_spatial_long_read","text":"Loads spatial long-read RNA-seq data GitHub repository. Includes coordinates, region annotations, deconvolution, library sizes, expression matrices genes isoforms.","code":""},{"path":"/reference/read_spatial_long_read.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Spatial Long-Read RNA-Seq Data — read_spatial_long_read","text":"","code":"read_spatial_long_read()"},{"path":"/reference/read_spatial_long_read.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Spatial Long-Read RNA-Seq Data — read_spatial_long_read","text":"list containing: coords Matrix spatial coordinates. regions Spatial region annotations. deconv Cell type deconvolution matrix. library_size Vector library sizes per spot. total_gene_expression Matrix total gene expression. isoform_expression Matrix isoform-level expression.","code":""},{"path":"/reference/read_spatial_long_read.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Spatial Long-Read RNA-Seq Data — read_spatial_long_read","text":"","code":"if (FALSE) { # \\dontrun{ long_read_data <- read_spatial_long_read() str(long_read_data) } # }"},{"path":"/reference/read_visium.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Visium Example Data from GitHub — read_visium","title":"Read Visium Example Data from GitHub — read_visium","text":"Downloads loads Visium spatial transcriptomics data GitHub repository. Includes coordinates, deconvolution, effective niche covariates, library sizes, gene counts.","code":""},{"path":"/reference/read_visium.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Visium Example Data from GitHub — read_visium","text":"","code":"read_visium()"},{"path":"/reference/read_visium.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Visium Example Data from GitHub — read_visium","text":"list containing: coords Matrix spatial coordinates. niche Effective niche covariate matrix. deconv Cell type deconvolution matrix. counts Gene expression count matrix. library_size Vector library sizes per spot.","code":""},{"path":"/reference/read_visium.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Visium Example Data from GitHub — read_visium","text":"","code":"if (FALSE) { # \\dontrun{ visium_data <- read_visium() str(visium_data) } # }"},{"path":"/reference/read_visiumHD.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Visium HD Example Data from GitHub — read_visiumHD","title":"Read Visium HD Example Data from GitHub — read_visiumHD","text":"Downloads loads spatial transcriptomics data Visium HD example dataset hosted public GitHub repository. includes spatial coordinates, gene expression counts, deconvolution results, effective niche estimates.","code":""},{"path":"/reference/read_visiumHD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Visium HD Example Data from GitHub — read_visiumHD","text":"","code":"read_visiumHD()"},{"path":"/reference/read_visiumHD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Visium HD Example Data from GitHub — read_visiumHD","text":"named list four elements: coords matrix data frame spatial coordinates (x y) spot. niche matrix, data frame, list representing effective niche composition per spot. deconv matrix data frame cell type deconvolution proportions per spot. counts gene expression count matrix (genes × spots).","code":""},{"path":"/reference/read_visiumHD.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read Visium HD Example Data from GitHub — read_visiumHD","text":"function requires internet connection download data https://github.com/kaishumason/SpotGLM-Example-Data. repository must contain files coords.rds, deconv_matrix.rds, count_matrix_subset.rds, niche.rds visiumHD folder.","code":""},{"path":"/reference/read_visiumHD.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Visium HD Example Data from GitHub — read_visiumHD","text":"","code":"if (FALSE) { # \\dontrun{ data_list <- read_visiumHD() head(data_list$coords) dim(data_list$counts) } # }"},{"path":"/reference/SE_optimizer.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Minimum Standard Error for Given Power and Effect — SE_optimizer","title":"Compute Minimum Standard Error for Given Power and Effect — SE_optimizer","text":"Calculates minimum standard error needed detect given effect specified power.","code":""},{"path":"/reference/SE_optimizer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Minimum Standard Error for Given Power and Effect — SE_optimizer","text":"","code":"SE_optimizer(min_effect, pow, alpha = 0.05, acc = 0.001)"},{"path":"/reference/SE_optimizer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Minimum Standard Error for Given Power and Effect — SE_optimizer","text":"min_effect Minimum effect size pow Desired power (e.g., 0.8 0.999) alpha Type error rate acc Accuracy search","code":""},{"path":"/reference/SE_power_optimizer.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize Standard Error for Target Power Approximation — SE_power_optimizer","title":"Optimize Standard Error for Target Power Approximation — SE_power_optimizer","text":"Finds smallest standard error achieves desired approximation target power.","code":""},{"path":"/reference/SE_power_optimizer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize Standard Error for Target Power Approximation — SE_power_optimizer","text":"","code":"SE_power_optimizer(   target_SE,   target_power_approx,   effect_min,   effect_max,   alpha = 0.05,   acc = 0.001 )"},{"path":"/reference/SE_power_optimizer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize Standard Error for Target Power Approximation — SE_power_optimizer","text":"target_SE Initial estimate standard error target_power_approx Desired power ratio (e.g., 0.95) effect_min Minimum effect size effect_max Maximum effect size alpha Type error rate acc Accuracy numeric optimization","code":""},{"path":"/reference/simulate_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate gene expression data — simulate_data","title":"Simulate gene expression data — simulate_data","text":"function simulates gene expression data using spot-based model","code":""},{"path":"/reference/simulate_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate gene expression data — simulate_data","text":"","code":"simulate_data(   n,   nct,   effect_range,   intercept_range,   min_effect = 0,   library_size = 500,   spot_ct = min(2, nct),   p = 6,   num_null = 2,   prob_ct = NULL,   family = \"poisson\",   dispersion = 1 )"},{"path":"/reference/simulate_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate gene expression data — simulate_data","text":"n Number data points nct Number cell types effect_range Range effect sizes (effect sizes drawn uniformly interval) intercept_range Range intercepts (intercept sizes drawn uniformly interval) min_effect Minimum absolute value effect sizes. library_size Number transcripts per cell/spot spot_ct Number cell types per spot p Number covariates num_null Number null coefficients include prob_ct Optional probabilities cell type sampling family data generating distribution. One poisson, negative binomial,binomial, gaussian dispersion Dispersion parameter NB Gaussian family. Size parameter NB sd Gaussian. Default: 1","code":""},{"path":"/reference/simulate_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate gene expression data — simulate_data","text":"list simulated y, X, lambda, beta, null_beta, CT","code":""}]
