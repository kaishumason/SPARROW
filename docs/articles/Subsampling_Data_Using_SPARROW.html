<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Subsampling Data Using SPARROW • sparrow</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Subsampling Data Using SPARROW">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">sparrow</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/MERFISH_Using_SPARROW.html">Subsampling MERFISH Data Using SPARROW</a></li>
    <li><a class="dropdown-item" href="../articles/Subsampling_Data_Using_SPARROW.html">Subsampling Data Using SPARROW</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/kaishumason/SPARROW/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Subsampling Data Using SPARROW</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/kaishumason/SPARROW/blob/HEAD/vignettes/Subsampling_Data_Using_SPARROW.Rmd"><code>vignettes/Subsampling_Data_Using_SPARROW.Rmd</code></a></small>
      <div class="d-none name"><code>Subsampling_Data_Using_SPARROW.Rmd</code></div>
    </div>

    
    
<p>You will need the following packages</p>
<pre><code><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/kaishumason/SPARROW">sparrow</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">spotglm</span><span class="op">)</span></span></code></pre>
<div class="section level2">
<h2 id="overview">Overview<a class="anchor" aria-label="anchor" href="#overview"></a>
</h2>
<p>SPARROW (Submodular Power Adaptive data Reduction for Representative
dOWnstream analysis) is a method that selects a subsample of size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
from a large scale dataset. The subsample is chosen such that it
maximizes the power of a downstream analysis (e.g. regression). This is
done by minimizing the trace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>X</mi><mi>T</mi></msup><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">(X^TX)^{-1}</annotation></semantics></math>
which corresponds to the sum of the square of the standard errors of a
standard linear regression. In the case of large scale spatial-omic data
that contains mixtures of cells called spots, the covariate matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mrow><mi>n</mi><mo>×</mo><mi>p</mi></mrow></msub><annotation encoding="application/x-tex">X_{n \times p}</annotation></semantics></math>
must be expanded to be of dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo>×</mo><mi>T</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">n \times (p\times T)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
is the number of cell types in the sample. More technical details can be
found in the supplementary.</p>
</div>
<div class="section level2">
<h2 id="step-1-simulating-data">Step 1: Simulating Data<a class="anchor" aria-label="anchor" href="#step-1-simulating-data"></a>
</h2>
<p>We use the simulate data function in sparrow to simulate 100,000
spots with 8 cell types. Each spot contains at most 2 cell types. We
simulate data according to the model
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mo>∼</mo><mi>P</mi><mi>o</mi><mi>i</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><mi>T</mi></munderover><msub><mi>λ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo>+</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1000</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Y_i \sim Pois(\sum_{t=1}^{T}\lambda_{i,t}\exp(X_i\beta^t + \log(1000)))</annotation></semantics></math>
Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">Y_i</annotation></semantics></math>
is the response (e.g. gene expression) for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>X</mi><mi>i</mi></msub><annotation encoding="application/x-tex">X_i</annotation></semantics></math>
is the covariate vector for spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
denotes a cell type,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mrow><mi>i</mi><mo>,</mo><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">\lambda_{i,t}</annotation></semantics></math>
is the deconvolution estimate for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
in spot
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>β</mi><mi>t</mi></msup><annotation encoding="application/x-tex">\beta^t</annotation></semantics></math>
is the effect vector for cell type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
Note that each cell type gets a different effect vector. Also note that
the columns of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
are bounded between 0 and 1. Bounding all columns between some interval
is recommended to prevent scaling issues and to make interpretation
easier.</p>
<pre><code><span><span class="va">data</span> <span class="op">=</span> <span class="fu">sparrow</span><span class="fu">::</span><span class="fu"><a href="../reference/simulate_data.html">simulate_data</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">1e5</span>, nct <span class="op">=</span> <span class="fl">8</span>,effect_range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">0.2</span>,<span class="fl">0.2</span><span class="op">)</span>,min_effect <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span>                              intercept_range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">6</span>,<span class="op">-</span><span class="fl">4</span><span class="op">)</span>,</span>
<span>                              library_size <span class="op">=</span> <span class="fl">1000</span>, spot_ct <span class="op">=</span> <span class="fl">2</span>,</span>
<span>                              p <span class="op">=</span> <span class="fl">8</span>,num_null <span class="op">=</span> <span class="fl">2</span>,prob_ct <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span></span></code></pre>
</div>
<div class="section level2">
<h2 id="step-2-expand-the-covariate-matrix-to-incorporate-deconvolution">Step 2: Expand the Covariate Matrix to Incorporate
Deconvolution<a class="anchor" aria-label="anchor" href="#step-2-expand-the-covariate-matrix-to-incorporate-deconvolution"></a>
</h2>
<p>The model above has a variance covariance matrix equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>Z</mi><mi>T</mi></msup><mi>A</mi><mi>Z</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">(Z^TAZ)^{-1}</annotation></semantics></math>.
The matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>
is equal to
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mi>X</mi><mo>*</mo><msub><mi>λ</mi><msub><mi>t</mi><mn>1</mn></msub></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mi>X</mi><mo>*</mo><msub><mi>λ</mi><msub><mi>t</mi><mi>T</mi></msub></msub><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">Z = [X*\lambda_{t_1},...X*\lambda_{t_T}]</annotation></semantics></math>
i.e. we append
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
copies of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>
together, weighted by the deconvolution vectors for each cell
type.<br>
The matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is diagonal with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mrow><mi>i</mi><mo>,</mo><mi>i</mi></mrow></msub><annotation encoding="application/x-tex">A_{i,i}</annotation></semantics></math>
approximately equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mi>t</mi></msup><mo>+</mo><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1000</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\exp(X_i\beta^t + \log(1000))</annotation></semantics></math>.
As
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">X_i\beta^t</annotation></semantics></math>
gets larger, there is more signal. Because we intend to estimate power
later, we fix a lower bound for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub><msup><mi>β</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">X_i\beta^t</annotation></semantics></math>
in order to place a conservative estimate on the standard error.<br>
For now, let this bound be equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>−</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">-5</annotation></semantics></math>.
In general, what one can do with spatial transcriptomic data is to
compute the proportion of total UMIs that come from the each
gene,compute the 75th percentile of these values, then convert this into
UMIs per 1000
(e.g. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1000</mn><mo>*</mo><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>−</mi><mn>5</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">1000*\exp(-5)</annotation></semantics></math>).
To expand our covariate matrix we use the “expand covariate matrix”
function which takes 6 arguments</p>
<details><summary>
Arguments
</summary><ul>
<li>X: The covariate matrix. Of dimension n by p</li>
<li>lambda: The deconvolution matrix for each spot. Of dimension n by
T</li>
<li>family: The family of the downstream glm process that one intends to
use.</li>
<li>lib size: The library size of each spot. Either a scalar or a vector
of length n</li>
<li>min reads per 1000: The minimum reads per 1000 that we want to test
for. This is only relevant for data selection later.</li>
<li>min freq: How many non-zero observations a column in the expanded
covariate matrix needs to be valid. Default is 500.</li>
</ul></details><pre><code><span><span class="va">expanded_X</span> <span class="op">=</span> <span class="fu">sparrow</span><span class="fu">::</span><span class="fu"><a href="../reference/expand_covariate_matrix.html">expand_covariate_matrix</a></span><span class="op">(</span>X <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">X</span>, lambda <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">lambda</span>,</span>
<span>                                            family <span class="op">=</span> <span class="st">"poisson"</span>,lib_size <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>                                            min_reads_per_1000 <span class="op">=</span> <span class="fl">1000</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="op">-</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span></span></code></pre>
<p>The output is a list with two entries. Valid is a matrix of dimension
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>
that tells us which cell type-covariate combinations have sample size
that exceed the min frequency. X holds the expanded covariate matrix,
removing the invalid cell type-covariate combinations.</p>
</div>
<div class="section level2">
<h2 id="step-3-compute-target-standard-error-of-subsample">Step 3: Compute Target Standard Error of Subsample<a class="anchor" aria-label="anchor" href="#step-3-compute-target-standard-error-of-subsample"></a>
</h2>
<p>The goal of SPARROW is to identify a subsample of the data such that
the subsampled data and the original data have similar power. This is
done by comparing the standard errors in the subsample and the standard
errors in the original dataset. Key to this procedure is specifying a
minimum effect size
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>δ</mi><mo>min</mo></msub><annotation encoding="application/x-tex">\delta_{\min}</annotation></semantics></math>.
This is the minimum effect size that one cares about identifying. For
example, in the case of poisson regression, one may not care about
identifying log fold changes less than a certain amount. In this case
let us choose
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mo>min</mo></msub><mo>=</mo><mn>0.05</mn></mrow><annotation encoding="application/x-tex">\delta_{\min} = 0.05</annotation></semantics></math>.<br>
For covariate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>,
let its standard error on the entire dataset be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\sigma_j</annotation></semantics></math>.
Under some assumptions one can compute the power when the standard error
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\sigma_j</annotation></semantics></math>
and the effect size is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mi>j</mi></msub><mo>,</mo><mi>δ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P(\sigma_j,\delta)</annotation></semantics></math>.
Define
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P(\sigma_j)</annotation></semantics></math>
as the average power the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>δ</mi><mo>min</mo></msub><mo>,</mo><msub><mi>δ</mi><mrow><mo>max</mo><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\delta_{\min},\delta_{\max,j}]</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>δ</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><annotation encoding="application/x-tex">\delta_{max}</annotation></semantics></math>
is defined as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mo>max</mo><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><munder><mo>min</mo><mi>δ</mi></munder><mo>:</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mi>j</mi></msub><mo>,</mo><mi>δ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>&gt;</mo><mn>0.999</mn></mrow><annotation encoding="application/x-tex">\delta_{\max,j} = \min_{\delta}: P(\sigma_j,\delta) &gt; 0.999</annotation></semantics></math></p>
<p>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mo>max</mo><mo>,</mo><mi>j</mi></mrow></msub><mo>&lt;</mo><msub><mi>δ</mi><mo>min</mo></msub></mrow><annotation encoding="application/x-tex">\delta_{\max,j} &lt; \delta_{\min}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0.999</mn></mrow><annotation encoding="application/x-tex">P(\sigma_j) = 0.999</annotation></semantics></math>.
Given
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P(\sigma_j)</annotation></semantics></math>,
we can compute
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mtext mathvariant="normal">target</mtext><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><munder><mo>max</mo><mrow><msub><mi>σ</mi><mi>j</mi></msub><mi>′</mi></mrow></munder><mo>:</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mi>j</mi></msub><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>&gt;</mo><mi>c</mi><mo>×</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>σ</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\sigma_{\text{target},j} = \max_{\sigma_j '}:P(\sigma_j ') &gt; c\times P(\sigma_j)</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
is a constant close to 1
(e.g. 0.99).<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mrow><mtext mathvariant="normal">target</mtext><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\sigma_{\text{target},j}</annotation></semantics></math>
represents the largest standard error at which we recover at least
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>
of the power that the original data has for covariate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>.
Below we compute the target standard errors when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mn>0.99</mn></mrow><annotation encoding="application/x-tex">c = 0.99</annotation></semantics></math>.
To compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mrow><mtext mathvariant="normal">target</mtext><mo>,</mo><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\sigma_{\text{target},j}</annotation></semantics></math>
we us the “compute target standard error” function. This takes 3
arguments</p>
<details><summary>
Arguments
</summary><ul>
<li>X: The expanded covariate matrix. Of dimension n by p</li>
<li>min effect: The smallest effect size we wish to detect</li>
<li>target power approximation: The power we wish to retain compared to
the standard error on the entire dataset be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\sigma_j</annotation></semantics></math>
</li>
</ul></details><pre><code><span><span class="va">target_standard_errors</span> <span class="op">=</span> <span class="fu">sparrow</span><span class="fu">::</span><span class="fu"><a href="../reference/compute_target_standard_error.html">compute_target_standard_error</a></span><span class="op">(</span>X <span class="op">=</span> <span class="va">expanded_X</span>,</span>
<span>                                min_effect <span class="op">=</span> <span class="fl">0.05</span>,target_power_approx <span class="op">=</span> <span class="fl">0.99</span><span class="op">)</span></span></code></pre>
<p>The output is a vector of target standard errors.</p>
</div>
<div class="section level2">
<h2 id="step-4-subsampling-via-sparrow-1-minute">Step 4: Subsampling via SPARROW (~1 minute)<a class="anchor" aria-label="anchor" href="#step-4-subsampling-via-sparrow-1-minute"></a>
</h2>
<p>SPARROW is a subsampling algorithm that attempts to minimize the
trace of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Z</mi><mi>K</mi><mi>T</mi></msubsup><mi>A</mi><msub><mi>Z</mi><mi>K</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">(Z_K^TAZ_K)^{-1}</annotation></semantics></math>.
Here
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Z</mi><mi>K</mi></msub><annotation encoding="application/x-tex">Z_K</annotation></semantics></math>
is a submatrix of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Z</mi><annotation encoding="application/x-tex">Z</annotation></semantics></math>
containing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
rows. This is done via stochastic greedy selection which can identify
solutions that are at least
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mn>1</mn><mi>/</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">1-1/e</annotation></semantics></math>
efficient. A natural stopping criterion is when
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>j</mi><mo>:</mo><msqrt><msubsup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>Z</mi><mi>K</mi><mi>T</mi></msubsup><mi>A</mi><msub><mi>Z</mi><mi>K</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>j</mi><mi>j</mi></mrow><mrow><mi>−</mi><mn>1</mn></mrow></msubsup></msqrt><mo>&lt;</mo><msub><mi>σ</mi><mrow><mtext mathvariant="normal">target</mtext><mo>,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\forall j: \sqrt{(Z_K^TAZ_K)^{-1}_{jj}} &lt; \sigma_{\text{target},j}</annotation></semantics></math></p>
<p>Note that when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>δ</mi><mrow><mo>max</mo><mo>,</mo><mi>j</mi></mrow></msub><mo>&lt;</mo><msub><mi>δ</mi><mo>min</mo></msub></mrow><annotation encoding="application/x-tex">\delta_{\max,j} &lt; \delta_{\min}</annotation></semantics></math>,
the amount of data needed to achieve the target standard error plateaus.
This is what characterizes to the ultra scalability of SPARROW.<br>
To run data selection we use the “data selection” function. It takes 5
arguments</p>
<details><summary>
Arguments
</summary><ul>
<li>X: The expanded covariate matrix. Of dimension p by n</li>
<li>data size: The maximum subsample size we want to take</li>
<li>min SE: A vector of the target standard errors</li>
<li>log: Logical of if we should log progress of data selection</li>
<li>period: If log is TRUE, how often we want to print progress in
iterations</li>
</ul></details><pre><code><span><span class="va">selected_indices</span> <span class="op">=</span> <span class="fu">sparrow</span><span class="fu">::</span><span class="fu"><a href="../reference/data_selection.html">data_selection</a></span><span class="op">(</span>X <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">expanded_X</span><span class="op">)</span>,</span>
<span>                        max_data_size <span class="op">=</span> <span class="fl">80000</span>,</span>
<span>                        min_standard_error <span class="op">=</span> <span class="va">target_standard_errors</span>,</span>
<span>                        log <span class="op">=</span> <span class="cn">TRUE</span>,period <span class="op">=</span> <span class="fl">5000</span><span class="op">)</span></span>
<span><span class="va">selected_indices</span> <span class="op">=</span> <span class="va">selected_indices</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">selected_indices</span><span class="op">)</span> <span class="op">==</span> <span class="cn">F</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"#Cells Subsampled: "</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">selected_indices</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre>
<p>The output is a vector of indices in the order they are selected.
Therefore if one initially picks a subset of size 100,000 but then wants
to downsample to 50,000 observations, they simply have to take the first
50,000 indices of the output. Note here that we select approximately
30,000 out of 100,000 total spots.</p>
</div>
<div class="section level2">
<h2 id="step-4-example-downstream-analysis-5-minuts">Step 4: Example Downstream Analysis (~5 minuts)<a class="anchor" aria-label="anchor" href="#step-4-example-downstream-analysis-5-minuts"></a>
</h2>
<p>To test the performance of our subsampled dataset, we will run
spotGLM on both the original dataset and the subsampled data. We see
that the power on both datasets are near identical.</p>
<pre><code><span><span class="va">nsim</span> <span class="op">=</span> <span class="fl">25</span></span>
<span><span class="va">full_power</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>,<span class="va">nsim</span><span class="op">)</span></span>
<span><span class="va">subset_power</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>,<span class="va">nsim</span><span class="op">)</span></span>
<span><span class="va">full_time</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>,<span class="va">nsim</span><span class="op">)</span></span>
<span><span class="va">subset_time</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>,<span class="va">nsim</span><span class="op">)</span></span>
<span><span class="va">t1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">nsim</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="co">#simulate new response vector</span></span>
<span>  <span class="va">expected_value</span> <span class="op">=</span> <span class="fu">spotglm</span><span class="fu">::</span><span class="va">spot_poisson</span><span class="op">$</span><span class="fu">predict</span><span class="op">(</span>X <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">X</span>,beta <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">beta</span>, </span>
<span>                                                 lambda <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">lambda</span>,</span>
<span>                                                 offset <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1000</span><span class="op">)</span>,</span>
<span>                                                              <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">y</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="va">expected_value</span> <span class="op">=</span> <span class="va">expected_value</span><span class="op">$</span><span class="va">total</span></span>
<span>  <span class="va">data</span><span class="op">$</span><span class="va">y</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Poisson.html" class="external-link">rpois</a></span><span class="op">(</span><span class="fl">1e5</span>,lambda <span class="op">=</span> <span class="va">expected_value</span><span class="op">)</span></span>
<span>  <span class="co">#run spotglm on original dataset</span></span>
<span>  <span class="va">model_full</span> <span class="op">=</span> <span class="fu">spotglm</span><span class="fu">::</span><span class="fu">run_model</span><span class="op">(</span>y <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">y</span>, X <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">X</span>, lambda <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">lambda</span>, </span>
<span>                        offset <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1000</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">y</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                        family <span class="op">=</span> <span class="st">"spot poisson"</span>,initialization <span class="op">=</span> <span class="cn">T</span>,</span>
<span>                        batch_size <span class="op">=</span> <span class="fl">500</span>,n_epochs <span class="op">=</span> <span class="fl">100</span>,</span>
<span>                        improvement_threshold <span class="op">=</span> <span class="fl">1e-6</span>,max_conv <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span>  <span class="co">#run spotglm on subsetted data</span></span>
<span>  <span class="va">model_subset</span> <span class="op">=</span> <span class="fu">spotglm</span><span class="fu">::</span><span class="fu">run_model</span><span class="op">(</span>y <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">y</span><span class="op">[</span><span class="va">selected_indices</span><span class="op">]</span>,</span>
<span>                        X <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">X</span><span class="op">[</span><span class="va">selected_indices</span>,<span class="op">]</span>, </span>
<span>                        lambda <span class="op">=</span> <span class="va">data</span><span class="op">$</span><span class="va">lambda</span><span class="op">[</span><span class="va">selected_indices</span>,<span class="op">]</span>, </span>
<span>                        offset<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1000</span><span class="op">)</span>,<span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">y</span><span class="op">)</span><span class="op">)</span><span class="op">[</span><span class="va">selected_indices</span><span class="op">]</span>,</span>
<span>                        family <span class="op">=</span> <span class="st">"spot poisson"</span>,initialization <span class="op">=</span> <span class="cn">T</span>,</span>
<span>                        batch_size <span class="op">=</span> <span class="fl">500</span>,n_epochs <span class="op">=</span> <span class="fl">100</span>,</span>
<span>                        improvement_threshold <span class="op">=</span> <span class="fl">1e-6</span>,max_conv <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#compute power </span></span>
<span>  <span class="va">full_sig</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">model_full</span><span class="op">$</span><span class="va">beta_est</span><span class="op">/</span><span class="va">model_full</span><span class="op">$</span><span class="va">stand_err_mat</span><span class="op">)</span><span class="op">&gt;</span><span class="fl">1.96</span></span>
<span>  <span class="va">subset_sig</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">model_subset</span><span class="op">$</span><span class="va">beta_est</span><span class="op">/</span><span class="va">model_subset</span><span class="op">$</span><span class="va">stand_err_mat</span><span class="op">)</span><span class="op">&gt;</span><span class="fl">1.96</span></span>
<span>  <span class="va">full_power</span><span class="op">[</span><span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">full_sig</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="va">data</span><span class="op">$</span><span class="va">null_beta</span><span class="op">)</span><span class="op">)</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="va">data</span><span class="op">$</span><span class="va">null_beta</span><span class="op">)</span></span>
<span>  <span class="va">subset_power</span><span class="op">[</span><span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">subset_sig</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="va">data</span><span class="op">$</span><span class="va">null_beta</span><span class="op">)</span><span class="op">)</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fl">1</span><span class="op">-</span><span class="va">data</span><span class="op">$</span><span class="va">null_beta</span><span class="op">)</span></span>
<span>  <span class="co">#sompute time</span></span>
<span>  <span class="va">full_time</span><span class="op">[</span><span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="va">model_full</span><span class="op">$</span><span class="va">time</span></span>
<span>  <span class="va">subset_time</span><span class="op">[</span><span class="va">j</span><span class="op">]</span> <span class="op">=</span> <span class="va">model_subset</span><span class="op">$</span><span class="va">time</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Sys.time.html" class="external-link">Sys.time</a></span><span class="op">(</span><span class="op">)</span> <span class="op">-</span> <span class="va">t1</span><span class="op">)</span></span></code></pre>
<pre><code><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"Mean Power on Full Data: "</span>, <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">full_power</span><span class="op">)</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste0</a></span><span class="op">(</span><span class="st">"Mean Power on Subsetted Data: "</span>, <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">subset_power</span><span class="op">)</span>,<span class="fl">3</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Kaishu Mason, Yijia Jiang, Nancy R. Zhang.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
